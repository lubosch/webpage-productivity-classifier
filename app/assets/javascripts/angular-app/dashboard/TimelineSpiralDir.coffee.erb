container = undefined
WIDTH = 800
HEIGHT = 600
scene = undefined
camera = undefined
renderer = undefined
controls = undefined
#  stats = undefined
planes = undefined
positive_planes = undefined
negative_planes = undefined
gui = undefined
changing = undefined
group_rot = 0
group = undefined
#D_Y = 25
#RADIUS = 300
TOTAL = 100
#PLANES_PER_ROTATION = 12
#ROT_SPEED = 20
#PLANE_OPACITY = 0.9
#TRANSPARENT = true
#WIREFRAME = false
RAD_CONST = Math.PI / 180

SETTINGS = {
  RADIUS: 300
  D_Y: 25
  PLANES_PER_ROTATION: 12
  PLANE_OPACITY: 0.9
  TRANSPARENT: true
  WIREFRAME: false
  ROT_SPEED: 20
  DIMENSION: false
}

angular.module('wpc').directive 'timelineSpiral', ->
  return {
  restrict: 'A'
  templateUrl: "<%= asset_path('angular-app/dashboard/timeline_spiral.html') %>"
  link: link
  }


link = (scope, element, attrs) ->
# COLORS
  RGB2Color = (r, g, b) ->
    '#' + byte2Hex(r) + byte2Hex(g) + byte2Hex(b)

  byte2Hex = (n) ->
    nybHexString = '0123456789ABCDEF'
    String(nybHexString.substr(n >> 4 & 0x0F, 1)) + nybHexString.substr(n & 0x0F, 1)

  if !Detector.webgl
    Detector.addGetWebGLMessage()
  # SCENE
  scene = new (THREE.Scene)
  # CAMERA
  camera = new (THREE.PerspectiveCamera)(45, WIDTH / HEIGHT, 1, 20000)
  camera.position.set 0, 0, 1000
  scene.add camera
  # RENDERER
  if Detector.webgl
    renderer = new (THREE.WebGLRenderer)(antialias: true)
  else
    renderer = new (THREE.CanvasRenderer)
  # CONTAINER
  #  container = document.createElement('div')
  container = $('#timeline-spiral')
  #  document.body.appendChild container
  container.append(renderer.domElement)
  # POINT LIGHT
  light = new (THREE.PointLight)(0xff0000)
  light.position.set 500, 500, 0
  scene.add light
  # AMBIEND LIGHT
  ambientLight = new (THREE.AmbientLight)(0xffffff)
  scene.add ambientLight
  # GROUP
  group = new (THREE.Object3D)
  scene.add group
  # PLANES
  positive_planes = []
  negative_planes = []
  planes = []
  frequency = .06
  red = undefined
  green = undefined
  blue = undefined
  currentColor = undefined
  i = 0
  while i < TOTAL
    red = Math.sin(frequency * i + 0) * 127 + 128
    green = Math.sin(frequency * i + 2) * 127 + 128
    blue = Math.sin(frequency * i + 4) * 127 + 128
    currentColor = RGB2Color(red, green, blue)
    box_positive = new (THREE.Mesh)(new (THREE.BoxGeometry)(100, 100, 50), new (THREE.MeshBasicMaterial)(
      color: currentColor
      wireframe: SETTINGS['WIREFRAME']
      opacity: SETTINGS['PLANE_OPACITY']
      transparent: SETTINGS['TRANSPARENT']
      blending: THREE.AdditiveBlending
      depthWrite: false
      depthTest: false))
    box_positive.overdraw = true
    box_positive.material.side = THREE.DoubleSide
    group.add box_positive
    positive_planes.push box_positive
    planes.push box_positive

    currentColor = RGB2Color(255-red, 255-green, 255-blue)
    box_negative = new (THREE.Mesh)(new (THREE.BoxGeometry)(100, 100, 50), new (THREE.MeshBasicMaterial)(
      color: currentColor
      wireframe: SETTINGS['WIREFRAME']
      opacity: SETTINGS['PLANE_OPACITY']
      transparent: SETTINGS['TRANSPARENT']
      blending: THREE.AdditiveBlending
      depthWrite: false
      depthTest: false))
    box_positive.overdraw = true
    box_positive.material.side = THREE.DoubleSide
    group.add box_negative
    negative_planes.push box_negative
    planes.push box_negative

    i++
  organizePlanes()
  # STATS
  #  stats = new Stats
  #  stats.domElement.style.position = 'absolute'
  #  stats.domElement.style.top = '0px'
  #stats.domElement.style.bottom = '0px';
  #  stats.domElement.style.zIndex = 100
  #  container.appendChild stats.domElement
  # MOUSE CONTROLS
  controls = new (THREE.TrackballControls)(camera, renderer.domElement)
  controls.addEventListener('change', render);
  # GUI
  gui = new (dat.GUI)
  radiusControl = gui.add(SETTINGS, 'RADIUS', 50, 500).step(10).name('radius')
  dyControl = gui.add(SETTINGS, 'D_Y', 5, 100).step(1).name('delta Y')
  perRotControl = gui.add(SETTINGS, 'PLANES_PER_ROTATION', 4, 25).step(1).name('planes / 360')
  alphaControl = gui.add(SETTINGS, 'PLANE_OPACITY', 0, 1).step(0.05).name('plane opacity')
  transparentControl = gui.add(SETTINGS, 'TRANSPARENT').name('transparent')
  wireframeControl = gui.add(SETTINGS, 'WIREFRAME').name('wireframe')
  rotSpeedControl = gui.add(SETTINGS, 'ROT_SPEED', 0, 100).step(1).name('rotation speed')
  dimensionControl = gui.add(SETTINGS, 'DIMENSION').name('3D')
  gui.close()
  radiusControl.onChange (value) ->
    organizePlanes()
    return
  dyControl.onChange (value) ->
    organizePlanes()
    return
  perRotControl.onChange (value) ->
    organizePlanes()
    return
  alphaControl.onChange (value) ->
    i = 0
    while i < TOTAL*2
      planes[i].material.opacity = SETTINGS['PLANE_OPACITY']
      i++
    return
  dimensionControl.onChange (value) ->
    organizePlanes()
    return
  transparentControl.onChange (value) ->
    plane = undefined
    i = 0
    while i < TOTAL*2
      plane = planes[i]
      plane.material.transparent = SETTINGS['TRANSPARENT']
      plane.material.depthWrite = plane.material.depthTest = !SETTINGS['TRANSPARENT']
      i++
    return
    wireframeControl.onChange (value) ->
      i = 0
      while i < TOTAL*2
        planes[i].material.wireframe = SETTINGS['WIREFRAME']
        i++
      return
  # RESIZE
  window.addEventListener 'resize', resizeHandler, false
  resizeHandler()
  # ANIMATE
  animate()
  return

organizePlanes = ->
  yPos = -(TOTAL * SETTINGS['D_Y']) / 2
  scaleX = 1
  anglePer = 360 / SETTINGS['PLANES_PER_ROTATION'] * RAD_CONST
  yRot = 270 * RAD_CONST
  plane = undefined
  i = 0
  debugger;
  while i < TOTAL
    if SETTINGS['DIMENSION']
      yPos += SETTINGS['D_Y']
      r = i * anglePer*SETTINGS['D_Y'] + SETTINGS['RADIUS']
      scaleX = 2*Math.PI*r/(SETTINGS['PLANES_PER_ROTATION'])/100
      positive_plane = positive_planes[i]
      positive_plane.position.x = Math.cos(i * anglePer) * (r + 25)
      positive_plane.position.z = Math.sin(i * anglePer) * (r + 25)
      positive_plane.position.y = 0
      positive_plane.rotation.y = yRot
      positive_plane.scale.x = scaleX
      negative_plane = negative_planes[i]
      negative_plane.position.x = Math.cos(i * anglePer) * (r - 25)
      negative_plane.position.z = Math.sin(i * anglePer) * (r - 25)
      negative_plane.position.y = 0
      negative_plane.rotation.y = yRot
      negative_plane.scale.x = scaleX
      negative_plane.visible = true
    else
      yPos += SETTINGS['D_Y']
      positive_plane = positive_planes[i]
      positive_plane.position.x = Math.cos(i * anglePer) * (SETTINGS['RADIUS']+25)
      positive_plane.position.z = Math.sin(i * anglePer) * (SETTINGS['RADIUS']+25)
      positive_plane.position.y = yPos
      positive_plane.rotation.y = yRot
      positive_plane.scale.x = 1

      negative_plane = negative_planes[i]
      negative_plane.visible = false


    yRot -= anglePer
    i++
  return

resizeHandler = ->
  camera.aspect = WIDTH / HEIGHT
  camera.updateProjectionMatrix()
  renderer.setSize WIDTH, HEIGHT
  #  controls.handleResize();
  render()
  return

animate = ->
  requestAnimationFrame animate
  controls.update()
  #  stats.update()
  # rotate group
  group.rotation.y = group_rot += 0.0001 * SETTINGS['ROT_SPEED']
  render()
  return

render = ->
  renderer.render scene, camera
  return


# ---
# generated by js2coffee 2.2.0